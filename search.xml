<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>书单</title>
      <link href="/2021/10/10/%E4%B9%A6%E5%8D%95/"/>
      <url>/2021/10/10/%E4%B9%A6%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<p>《高性能mysql》</p><p>《RocketMQ技术内幕：RocketMQ架构设计与实现原理》</p><p>《数据密集型应用设计》</p><p>《Java并发编程实战》</p><p>《Java性能权威指南》</p><p>《重构》</p><p>《代码整洁之道》</p><p>《Effective Java》</p><p>《性能之巅：洞悉系统、企业与云计算》</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jvm相关</title>
      <link href="/2021/09/20/jvm%E7%9B%B8%E5%85%B3/"/>
      <url>/2021/09/20/jvm%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h5 id="JVM调优（官方文档）？"><a href="#JVM调优（官方文档）？" class="headerlink" title="JVM调优（官方文档）？"></a>JVM调优（<a href="https://docs.oracle.com/en/java/javase/17/gctuning/other-considerations.html#GUID-28448147-EC4C-4C94-9A54-54152AD21CB8">官方文档</a>）？</h5><p>JVM是Java Virtual Machine（Java虚拟机）的缩写，Java代码在不同平台上运行时不需要重新编译，Java语言使用JVM屏蔽了与具体平台相关的硬件指令差异，使得Java语言编译程序只需生成在JVM上运行的字节码，实现在多种平台上不加修改地运行。JVM包括即时编译（JIT）、内存管理（垃圾回收GC技术）和Runtime技术，其中GC调优是性能调优中应用最为广泛。本章调优思路主要针对GC展开说明：</p><ol><li><p>首先优选尽可能高的JDK版本，高版本有更新的特性和优化，对Java程序性能有好处；</p></li><li><p>其次根据实际业务场景和硬件资源给JVM选择合理的堆空间；</p></li><li><p>最后要选择合理的GC算法。</p><p>同时，Java自带很多工具，对程序运行的检测和性能分析都很有帮助，利用这些工具可以辅助Java性能调优。</p></li></ol><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><h5 id="（一）对象的生死"><a href="#（一）对象的生死" class="headerlink" title="（一）对象的生死"></a>（一）对象的生死</h5><h6 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h6><p><code>Java</code> <strong>堆</strong> 中每个具体对象（<strong>不是引用</strong>）都有一个<strong>引用计数器</strong>。当一个对象被创建并初始化赋值后，该变量计数设置为<code>1</code>。每当有一个地方引用它时，计数器值就<strong>加1</strong>。当引用<strong>失效</strong>时，即一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时，计数器值就<strong>减1</strong>。任何引用计数为<code>0</code>的对象可以被当作<strong>垃圾收集</strong>。当一个对象被垃圾收集时，它引用的任何对象计数减1。</p><h6 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h6><p><strong>可达性分析算法</strong>也叫<strong>根搜索算法</strong>，通过一系列的称为 <code>GC Roots</code> 的对象作为起点，然后向下搜索。搜索所走过的<strong>路径</strong>称为引用链 （<code>Reference Chain</code>）， 当一个<strong>对象</strong>到 <code>GC Roots</code> 没有任何<strong>引用链</strong>相连时, 即该对象<strong>不可达</strong>，也就说明此对象是 <strong>不可用的</strong>。</p><h5 id="（二）对象引用分类"><a href="#（二）对象引用分类" class="headerlink" title="（二）对象引用分类"></a>（二）对象引用分类</h5><h6 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h6><h6 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h6><h6 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h6><h6 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h6><h5 id="（三）finalize二次标记"><a href="#（三）finalize二次标记" class="headerlink" title="（三）finalize二次标记"></a>（三）finalize二次标记</h5><h5 id="（四）垃圾回收算法"><a href="#（四）垃圾回收算法" class="headerlink" title="（四）垃圾回收算法"></a>（四）垃圾回收算法</h5><h6 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h6><h6 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h6><h6 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h6><h6 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h6><h5 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h5><h5 id="诊断工具"><a href="#诊断工具" class="headerlink" title="诊断工具"></a>诊断工具</h5><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5>]]></content>
      
      
      
        <tags>
            
            <tag> jvm调优-常见概念工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo基本使用</title>
      <link href="/2021/09/20/hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/09/20/hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h5 id="创建一篇文章"><a href="#创建一篇文章" class="headerlink" title="创建一篇文章"></a>创建一篇文章</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;hexo基本使用&quot;</span><br></pre></td></tr></table></figure><p>创建成功之后会在 /</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo基本使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列-RabbitMq</title>
      <link href="/2021/09/12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%80%BB%E8%A7%88/"/>
      <url>/2021/09/12/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%80%BB%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<h4 id="RabbitMq"><a href="#RabbitMq" class="headerlink" title="RabbitMq"></a>RabbitMq</h4><h6 id=""><a href="#" class="headerlink" title=""></a></h6>]]></content>
      
      
      <categories>
          
          <category> 消息队列系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis概况</title>
      <link href="/2021/09/12/redis%E6%A6%82%E5%86%B5/"/>
      <url>/2021/09/12/redis%E6%A6%82%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h4><p>Redis的全称是-Remote Dictionary Server(远程字典服务器),Redis是一个基于内存的key-value非关系型数据库，由于基于内存暂储与一些其他特性，redis可以作为一个高性能缓存数据库,当然redis的作用不止于此。</p><h4 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a>Redis特性</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><p>String，List，Set，Sorted Set ，hashes当然还有其他</p><h5 id="持久化方式-官方文档"><a href="#持久化方式-官方文档" class="headerlink" title="持久化方式(官方文档)"></a>持久化方式(<a href="https://redis.io/topics/persistence">官方文档</a>)</h5><h6 id="操作方式"><a href="#操作方式" class="headerlink" title="操作方式"></a>操作方式</h6><p>RDBorAOF : 详情请见(AOF,RDB操作实践)</p><h6 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h6><p>服务器会收到每个写操作，服务器启动的时候会再次运行，重建数据集。</p><p>优点:</p><p>1.使用AOF能最大限度的保留数据,可选策略为no fsync at all, fsync every second, fsync at every query由后台线程执行，因此在最多只会丢失一秒钟的数据</p><p>2.日志是附加日志(我理解是只是增加个命令,当这个命令写不全的时候顶多删除这个命令，不会导致一整个文件用不了)</p><p>3.能自动重写，当写入的文件太大会自动创建一个新的文件</p><p>4.当使用了错误的命令删除了内容例如flushaall，可以打开AOF文件删除这个命令再去重启redis服务器读取</p><p>劣势:</p><p>1.AOF 文件比RDB 大</p><p>2.AOF比RDB慢,因为需要根据策略持久化写入日志</p><p>3.由于是执行所有的写入日志，可能会因为有缺陷的命令导致无法恢复AOF文件(当然官方说概率比较小)</p><h6 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h6><p>以指定时间对保存数据集的某个时间节点的快照</p><p>优点：</p><p>1.恢复数据集快，因为是指定时间点存储的快照，可以指定版本</p><p>2.适合灾难恢复，文件较小且加密（紧凑文件）</p><p>3.支持转移部分文件恢复</p><p>劣势：</p><p>1.可能会造成数据大量丢失，原因是数据是按照时间段持久化的</p><p>2.数据量较大的时候持久化的速度慢，可能会停止几毫秒甚至一秒</p><h5 id="淘汰策略（LRU算法）"><a href="#淘汰策略（LRU算法）" class="headerlink" title="淘汰策略（LRU算法）"></a>淘汰策略（LRU算法）</h5><p>设置最大存储大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置Redis最大占用内存大小为100M</span><br><span class="line">maxmemory 100mb</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置Redis最大占用内存大小为100M</span><br><span class="line">127.0.0.1:6379&gt; config set maxmemory 100mb</span><br><span class="line">//获取设置的Redis能使用的最大内存大小</span><br><span class="line">127.0.0.1:6379&gt; config get maxmemory</span><br></pre></td></tr></table></figure><p>设置淘汰策略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxmemory-policy</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure><p>修改redis.conf设置淘汰策略</p><ul><li>noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）</li><li>allkeys-lru：从所有key中使用LRU算法进行淘汰</li><li>volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰</li><li>allkeys-random：从所有key中随机淘汰数据</li><li>volatile-random：从设置了过期时间的key中随机淘汰</li><li>volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰</li><li></li></ul><p>总结：由两个lru策略,和两个随机策略,分别针对未设置超时时间和设置超时时间的主键，与一个错误的异常；</p><h5 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h5><h4 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h4><h5 id="会话缓存（Session-Cache）"><a href="#会话缓存（Session-Cache）" class="headerlink" title="会话缓存（Session Cache）"></a>会话缓存（Session Cache）</h5><p>用于</p><h5 id="全页面缓存（FPC）"><a href="#全页面缓存（FPC）" class="headerlink" title="全页面缓存（FPC）"></a>全页面缓存（FPC）</h5><h5 id="队列-FIFO"><a href="#队列-FIFO" class="headerlink" title="队列(FIFO)"></a>队列(FIFO)</h5><h5 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h5><h5 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h5><h4 id="Redis-高可用"><a href="#Redis-高可用" class="headerlink" title="Redis 高可用"></a>Redis 高可用</h4><h5 id="Redis集群搭建"><a href="#Redis集群搭建" class="headerlink" title="Redis集群搭建"></a>Redis集群搭建</h5><h5 id="主键失效策略"><a href="#主键失效策略" class="headerlink" title="主键失效策略"></a>主键失效策略</h5><h5 id="Redis调优"><a href="#Redis调优" class="headerlink" title="Redis调优"></a>Redis调优</h5><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="Redis客户端"><a href="#Redis客户端" class="headerlink" title="Redis客户端"></a>Redis客户端</h5><h6 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h6><h6 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h6><h6 id="Lettuce"><a href="#Lettuce" class="headerlink" title="Lettuce"></a>Lettuce</h6><h5 id="问题以及解决方案"><a href="#问题以及解决方案" class="headerlink" title="问题以及解决方案"></a>问题以及解决方案</h5><h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><p>使用一款工具多数情况我们不止要懂得如何使用，更多的情况是要知道使用会带来什么样的问题，这可以让我们更清楚的了解这款工具。</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      
      
      <categories>
          
          <category> Redis系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2021/09/11/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2021/09/11/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h5 id="一-第一个标题"><a href="#一-第一个标题" class="headerlink" title="一.第一个标题"></a>一.第一个标题</h5>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试系列 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
